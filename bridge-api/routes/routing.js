const express = require('express');
const { Client } = require('@googlemaps/google-maps-services-js');
const router = express.Router();

const client = new Client({});

// --- DATA (already generated by your build script) ---
const bridges = require('../data/low_clearance_bridges.json');        // [{id, latitude, longitude, clearance_ft}]
let noTruckZones = [];
let residentialZones = [];
try { noTruckZones = require('../data/no_truck_zones.json'); } catch {}
try { residentialZones = require('../data/residential_zones.json'); } catch {}

// ----------------- helpers -----------------

// Haversine distance in meters
function haversineMeters(a, b) {
  const R = 6371000;
  const toRad = (x) => (x * Math.PI) / 180;
  const dLat = toRad(b.lat - a.lat);
  const dLng = toRad(b.lng - a.lng);
  const lat1 = toRad(a.lat);
  const lat2 = toRad(b.lat);
  const x =
    Math.sin(dLat / 2) ** 2 +
    Math.cos(lat1) * Math.cos(lat2) * Math.sin(dLng / 2) ** 2;
  return 2 * R * Math.asin(Math.sqrt(x));
}

// Ray-casting point-in-polygon
function pointInPolygon(point, polygon) {
  const x = point.lat, y = point.lng;
  let inside = false;
  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
    const xi = polygon[i].lat, yi = polygon[i].lng;
    const xj = polygon[j].lat, yj = polygon[j].lng;
    const intersect = ((yi > y) !== (yj > y)) &&
      (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
    if (intersect) inside = !inside;
  }
  return inside;
}

// Google’s encoded polyline decoder
function decodePolyline(str) {
  let index = 0, lat = 0, lng = 0, coordinates = [];
  while (index < str.length) {
    let b, shift = 0, result = 0;
    do { b = str.charCodeAt(index++) - 63; result |= (b & 0x1f) << shift; shift += 5; } while (b >= 0x20);
    const dlat = (result & 1) ? ~(result >> 1) : (result >> 1);
    lat += dlat;
    shift = 0; result = 0;
    do { b = str.charCodeAt(index++) - 63; result |= (b & 0x1f) << shift; shift += 5; } while (b >= 0x20);
    const dlng = (result & 1) ? ~(result >> 1) : (result >> 1);
    lng += dlng;
    coordinates.push({ lat: lat / 1e5, lng: lng / 1e5 });
  }
  return coordinates;
}

// Score hazards for a polyline
function scoreRoute(points, { bridgeBufferMeters = 50 } = {}) {
  const hazards = { lowBridges: [], noTruckZones: [], residentialZones: [] };

  // 1) Low bridges (<= 13 ft) near route
  for (const b of bridges) {
    if (b.clearance_ft == null || b.clearance_ft > 13) continue;
    const bp = { lat: b.latitude, lng: b.longitude };
    for (const p of points) {
      if (haversineMeters(bp, p) <= bridgeBufferMeters) {
        hazards.lowBridges.push({
          id: b.id || b.structure_id || `${b.latitude},${b.longitude}`,
          latitude: b.latitude,
          longitude: b.longitude,
          clearance_ft: b.clearance_ft
        });
        break;
      }
    }
  }

  // 2) Zones — count once if any route point lies inside polygon
  const checkZones = (zones, bucket) => {
    for (const z of zones) {
      const poly = z.polygon || [];
      if (!poly.length) continue;
      for (const p of points) {
        if (pointInPolygon(p, poly)) {
          hazards[bucket].push({ id: z.id, name: z.name });
          break;
        }
      }
    }
  };
  checkZones(noTruckZones, 'noTruckZones');
  checkZones(residentialZones, 'residentialZones');

  const score = hazards.lowBridges.length * 10 + hazards.noTruckZones.length * 5 + hazards.residentialZones.length * 3;
  return { hazards, score };
}

// ----------------- debug -----------------
router.get('/ping', (req, res) => {
  res.json({ ok: true, where: 'routes/routing.js' });
});

// ----------------- main: safe-route -----------------
router.post('/safe-route', async (req, res) => {
  try {
    const { origin, destination, originAddress, destinationAddress, truck, tuning } = req.body || {};

    // Accept addresses OR lat/lng
    const originParam =
      (originAddress && originAddress.trim()) ||
      (origin && typeof origin.lat === 'number' && typeof origin.lng === 'number'
        ? `${origin.lat},${origin.lng}` : null);

    const destParam =
      (destinationAddress && destinationAddress.trim()) ||
      (destination && typeof destination.lat === 'number' && typeof destination.lng === 'number'
        ? `${destination.lat},${destination.lng}` : null);

    if (!originParam || !destParam) {
      return res.status(400).json({
        error: 'origin/destination required',
        detail: 'Provide originAddress & destinationAddress OR origin.lat/lng & destination.lat/lng'
      });
    }

    if (!process.env.GOOGLE_MAPS_API_KEY) {
      return res.status(500).json({ error: 'GOOGLE_MAPS_API_KEY not set on server' });
    }

    const bridgeBufferMeters = Number(tuning?.bridgeBufferMeters ?? 50);
    const truckHeightFt = Number(truck?.height_ft ?? 13);

    // Call Google Directions with alternatives
    const response = await client.directions({
      params: {
        origin: originParam,
        destination: destParam,
        mode: 'driving',
        alternatives: true,
        departure_time: 'now',
        key: process.env.GOOGLE_MAPS_API_KEY
      },
      timeout: 15000
    });

    const routes = response.data.routes || [];
    if (!routes.length) return res.status(502).json({ error: 'No routes returned from Google Directions' });

    // Evaluate routes
    const evaluated = routes.map((r, idx) => {
      const enc = r.overview_polyline?.points;
      const pts = enc ? decodePolyline(enc) : [];
      const { hazards, score } = scoreRoute(pts, { bridgeBufferMeters });

      const firstLeg = (r.legs && r.legs[0]) || {};
      const distance_m = firstLeg.distance?.value ?? null;
      const duration_s = firstLeg.duration_in_traffic?.value ?? firstLeg.duration?.value ?? null;

      return {
        idx,
        route: r,
        encoded: enc || null,
        summary: r.summary || '',
        distance_m,
        duration_s,
        hazards,
        score,
        pointsCount: pts.length
      };
    });

    const safe = evaluated.find(e => e.score === 0);
    const best = safe || evaluated.reduce((a, b) => (a.score <= b.score ? a : b));

    return res.json({
      chosenRouteIndex: best.idx,
      chosenRoute: best.route,
      chosenRouteHazards: best.hazards,
      routes: evaluated.map(e => ({
        index: e.idx,
        encoded: e.encoded,
        summary: e.summary,
        distance_m: e.distance_m,
        duration_s: e.duration_s,
        score: e.score,
        hazards: e.hazards
      })),
      usedTruckProfile: { height_ft: Math.min(truckHeightFt || 13, 13) },
      usedTuning: { bridgeBufferMeters }
    });

  } catch (err) {
    console.error('safe-route error:', err?.response?.data || err.message);
    return res.status(500).json({
      error: 'Error fetching directions',
      detail: err?.response?.data || err.message
    });
  }
});

module.exports = router;
